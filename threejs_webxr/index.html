<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Three.js Volume â€” VR-safe (no static) + Controllers + Mobile Perf</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            color: #ddd;
            font: 12px system-ui
        }

        #hud {
            position: fixed;
            left: 8px;
            bottom: 8px;
            background: rgba(0, 0, 0, .35);
            padding: 6px 8px;
            border-radius: 6px;
            white-space: pre
        }

        #tooltip {
            position: fixed;
            left: 0;
            top: 0;
            transform: translate(12px, 12px);
            background: rgba(0, 0, 0, .7);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font: 12px system-ui;
            white-space: pre;
            pointer-events: none;
            display: none;
            border: 1px solid rgba(255, 255, 255, .15)
        }

        #tip {
            position: fixed;
            right: 8px;
            bottom: 8px;
            background: rgba(0, 0, 0, .45);
            color: #fff;
            padding: 8px 10px;
            border-radius: 6px;
            font: 12px system-ui;
            display: none
        }

        #progress {
            position: fixed;
            left: 8px;
            top: 8px;
            background: rgba(0, 0, 0, .6);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font: 12px system-ui;
            display: none
        }
    </style>
    <script type="importmap">
  { "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }}
  </script>
</head>

<body>
    <div id="hud"></div>
    <div id="tooltip"></div>
    <div id="tip"></div>
    <div id="progress"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

        if (!document.createElement('canvas').getContext('webgl2')) {
            document.body.innerHTML = '<div style="padding:20px;color:#ddd">WebGL2 is required.</div>';
            throw new Error('WebGL2 not available');
        }

        /* ---------- Scene/Renderer ---------- */
        const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.01, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(isiOS ? 1 : Math.min(2, devicePixelRatio));
        renderer.setSize(innerWidth, innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local-floor');
        renderer.domElement.style.touchAction = 'none';
        document.body.appendChild(renderer.domElement);

        const gl = renderer.getContext();
        const MAX3D = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE) || 256; // safety

        const hud = document.getElementById('hud');
        const tooltipEl = document.getElementById('tooltip');
        const tip = document.getElementById('tip');
        const progressEl = document.getElementById('progress');

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
        camera.position.set(0, 0, 3); controls.update();

        /* ---------- CONFIG ---------- */
        const NUM_SLICES_ORIG = 451;
        const START_INDEX = 1;
        const IMG_PATH = i => `./TranslationScaleCrop/${i + START_INDEX}.png`;

        const SPACING = new THREE.Vector3(1, 1, 1);
        let STEPS = 512; // adapt later
        const CLIM = new THREE.Vector2(0.10, 0.95);
        const BASE_ALPHA = 0.80;

        // UI/drag affordances
        const FRAME_SCALE = 1.35;
        const FRAME_PROXY_PAD = 0.30;

        // Progressive + streaming
        const K_COARSE = isiOS ? 12 : 8;               // coarser first on iOS
        const MAX_CONCURRENCY = isiOS ? 3 : 6;         // less parallelism on iOS
        const PROGRESS_UPDATE_EVERY = isiOS ? 16 : 8;  // fewer texture reuploads

        /* ---------- Helpers ---------- */
        function fitCameraToObject(obj, fit = 1.35) {
            const box = new THREE.Box3().setFromObject(obj);
            const size = new THREE.Vector3(); box.getSize(size);
            const center = new THREE.Vector3(); box.getCenter(center);
            controls.target.copy(center);
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = (maxDim / 2) / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
            camera.position.copy(center).add(new THREE.Vector3(0, 0, dist * fit));
            camera.near = Math.max(0.01, dist / 100); camera.far = dist * 200; camera.updateProjectionMatrix();
        }

        async function loadImageData(url, targetW = null, targetH = null) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.decoding = 'async';
            img.src = url;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error('Image failed to load: ' + url));
            });

            let tw = img.naturalWidth, th = img.naturalHeight;
            if (targetW && targetH) { tw = targetW; th = targetH; }

            const hasCreateImageBitmap = typeof createImageBitmap === 'function';
            const hasOffscreen = typeof OffscreenCanvas !== 'undefined';

            let bmp = null;
            if (hasCreateImageBitmap) {
                try { bmp = await createImageBitmap(img, { resizeWidth: tw, resizeHeight: th, resizeQuality: 'high' }); }
                catch (_) { }
            }

            const canvas = hasOffscreen ? new OffscreenCanvas(tw, th) : document.createElement('canvas');
            canvas.width = tw; canvas.height = th;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            if (bmp) { ctx.drawImage(bmp, 0, 0); if (bmp.close) try { bmp.close(); } catch { } }
            else { ctx.drawImage(img, 0, 0, tw, th); }

            return ctx.getImageData(0, 0, tw, th);
        }

        function createTextSprite(text, color = '#ffffff', scale = 0.18) {
            const w = 256, h = 128;
            const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            const tex = new THREE.CanvasTexture(canvas); tex.minFilter = THREE.LinearFilter;
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, transparent: true });
            const spr = new THREE.Sprite(mat); spr.scale.set(scale, scale * 0.5, 1);
            function draw(t) {
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                const r = 20; ctx.beginPath();
                ctx.moveTo(r, 0); ctx.lineTo(w - r, 0); ctx.quadraticCurveTo(w, 0, w, r);
                ctx.lineTo(w, h - r); ctx.quadraticCurveTo(w, h, w - r, h);
                ctx.lineTo(r, h); ctx.quadraticCurveTo(0, h, 0, h - r);
                ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0); ctx.closePath(); ctx.fill();
                ctx.fillStyle = color; ctx.font = 'bold 56px system-ui, sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(t, w / 2, h / 2);
                tex.needsUpdate = true;
            }
            spr.userData.setText = draw; draw(text); return spr;
        }

        class DragController {
            constructor(camera, dom, orbit) {
                this.camera = camera; this.dom = dom; this.orbit = orbit;
                this.ray = new THREE.Raycaster(); this.pointer = new THREE.Vector2(); this.dragging = null;
                this.pickables = null;
                dom.addEventListener('pointerdown', e => this.onDown(e));
                dom.addEventListener('pointermove', e => this.onMove(e));
                dom.addEventListener('pointerup', e => this.onUp(e));
                dom.addEventListener('pointercancel', e => this.onUp(e));
            }
            setScene(s) { this.scene = s; }
            setPickables(list) { this.pickables = list; }
            _updatePointer(e) {
                const r = this.dom.getBoundingClientRect();
                this.pointer.x = ((e.clientX + r.left * -1) / r.width) * 2 - 1; this.pointer.y = -((e.clientY - r.top) / r.height) * 2 + 1;
            }

            onDown(e) {
                this._updatePointer(e);
                this.ray.setFromCamera(this.pointer, this.camera);
                const hits = this.ray.intersectObjects(this.pickables || this.scene.children, true);

                let chosen = null;
                for (const h of hits) {
                    let o = h.object;
                    while (o && !o.userData.dragOpts) o = o.parent;
                    if (!o) continue;
                    chosen = { obj: o, hit: h, opts: o.userData.dragOpts }; break;
                }
                if (!chosen) return;

                const isTouch = e.pointerType === 'touch';
                if (!isTouch && !e.shiftKey && chosen.opts.id !== 'arb-rot') return;

                const moveObj = chosen.opts.target || chosen.obj;
                const dragging = { obj: moveObj, opts: chosen.opts, hit: chosen.hit, mode: 'translate' };

                if (chosen.opts.id === 'arb-rot' || (chosen.opts.id === 'arb' && (e.ctrlKey || e.metaKey))) {
                    dragging.mode = 'rotate';
                    dragging.lastXY = { x: e.clientX, y: e.clientY };
                } else {
                    const n = this.camera.getWorldDirection(new THREE.Vector3()).normalize();
                    dragging.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(n, chosen.hit.point.clone());
                    dragging.offset = chosen.hit.point.clone().sub(moveObj.getWorldPosition(new THREE.Vector3()));
                }

                this.dragging = dragging;
                if (this.orbit) this.orbit.enabled = false;
                e.preventDefault();
            }

            onMove(e) {
                if (!this.dragging) return;
                const { obj, opts, mode } = this.dragging;

                if (mode === 'rotate') {
                    const dx = e.clientX - this.dragging.lastXY.x;
                    const dy = e.clientY - this.dragging.lastXY.y;
                    this.dragging.lastXY.x = e.clientX; this.dragging.lastXY.y = e.clientY;
                    const k = 0.005;
                    obj.rotation.y -= dx * k;
                    obj.rotation.x -= dy * k;
                    opts.onChange(obj);
                    return;
                }

                this._updatePointer(e); this.ray.setFromCamera(this.pointer, this.camera);
                const p = new THREE.Vector3();
                if (!this.ray.ray.intersectPlane(this.dragging.plane, p)) return;
                const targetWorld = p.clone().sub(this.dragging.offset);
                const parent = obj.parent || this.scene;
                const targetLocal = parent.worldToLocal(targetWorld.clone());
                if (opts.axis === 'x') { targetLocal.y = obj.position.y; targetLocal.z = obj.position.z; }
                if (opts.axis === 'y') { targetLocal.x = obj.position.x; targetLocal.z = obj.position.z; }
                if (opts.axis === 'z') { targetLocal.x = obj.position.x; targetLocal.y = obj.position.y; }
                obj.position.copy(targetLocal);
                opts.onChange(obj);
            }

            onUp() { if (this.dragging && this.orbit) this.orbit.enabled = true; this.dragging = null; }
        }

        /* ---------- World Root (for VR grab/turn) ---------- */
        const worldRoot = new THREE.Group();
        scene.add(worldRoot);

        /* ---------- Main build ---------- */
        let frontMat, rt, volume, frameX, frameY, frameZ, arbRect, arbArrow, clip;
        let boxPick, pickables = [];
        let back, front;
        let tex3D = null;
        let volU8 = null;

        const hoverRay = new THREE.Raycaster();
        const pointerNDC = new THREE.Vector2();
        let hoveredFrame = null;
        const baseCol = new THREE.Color(0xff6b6b);
        const hiCol = new THREE.Color(0xffb2b2);

        (async function build() {
            try {
                // 0) Probe first slice
                const first = await loadImageData(IMG_PATH(0));
                let W0 = first.width, H0 = first.height, D0 = NUM_SLICES_ORIG;

                // 1) Cap to GPU limits: downscale XY, stride Z
                const xyScale = Math.min(1, MAX3D / Math.max(W0, H0));
                const depthStride = Math.max(1, Math.ceil(D0 / Math.min(D0, MAX3D)));

                const W = Math.max(1, Math.floor(W0 * xyScale));
                const H = Math.max(1, Math.floor(H0 * xyScale));
                const D = Math.ceil(D0 / depthStride);
                const sliceIndexForZ = z => Math.min(D0 - 1, z * depthStride);

                // 2) Scene primitives (before full load)
                const worldSize = new THREE.Vector3(W * SPACING.x, H * SPACING.y, D * SPACING.z);
                const fit = 1.0 / Math.max(worldSize.x, worldSize.y, worldSize.z);
                const scaledFull = worldSize.clone().multiplyScalar(fit);
                volume = new THREE.Group(); volume.scale.copy(scaledFull);
                worldRoot.add(volume); // attach to world root for VR manipulation

                // adaptive steps
                const maxDim = Math.max(W, H, D);
                STEPS = Math.round(maxDim * (isiOS ? 0.65 : 0.75));

                // Exit-coordinate RT (will render mono during XR)
                const dpr = renderer.getPixelRatio();
                rt = new THREE.WebGLRenderTarget(
                    Math.floor(innerWidth * dpr), Math.floor(innerHeight * dpr),
                    {
                        type: THREE.HalfFloatType,   // half-float helps reduce shimmer
                        format: THREE.RGBAFormat,
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        depthBuffer: true,
                        stencilBuffer: false
                    }
                );

                const boxGeo = new THREE.BoxGeometry(1, 1, 1);
                const backMat = new THREE.ShaderMaterial({
                    side: THREE.BackSide,
                    vertexShader: `varying vec3 v01; void main(){ v01=position*0.5+0.5; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
                    fragmentShader: `precision highp float; varying vec3 v01; void main(){ gl_FragColor=vec4(v01,1.0); }`
                });
                back = new THREE.Mesh(boxGeo, backMat); volume.add(back);

                clip = {
                    u_clipX: { value: new THREE.Vector4(1, 0, 0, 0.5) },
                    u_clipY: { value: new THREE.Vector4(0, 1, 0, 0.5) },
                    u_clipZ: { value: new THREE.Vector4(0, 0, 1, 0.5) },
                    u_clipArb: { value: new THREE.Vector4(0, 0, 1, 0.5) },
                    u_useX: { value: true },
                    u_useY: { value: true },
                    u_useZ: { value: true },
                    u_useArb: { value: false }
                };
                frontMat = new THREE.ShaderMaterial({
                    side: THREE.FrontSide, transparent: false, depthWrite: true,
                    uniforms: {
                        u_data: { value: null }, u_exit: { value: rt.texture },
                        u_res: { value: new THREE.Vector2(rt.width, rt.height) },
                        u_steps: { value: STEPS }, u_baseA: { value: BASE_ALPHA }, u_clim: { value: CLIM.clone() },
                        ...clip
                    },
                    vertexShader: `varying vec3 v01; void main(){ v01=position*0.5+0.5; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
                    fragmentShader:/*glsl*/`
            precision highp float; precision highp sampler3D;
            uniform sampler3D u_data; uniform sampler2D u_exit;
            uniform vec2 u_res; uniform vec2 u_clim;
            uniform int u_steps; uniform float u_baseA;
            uniform vec4 u_clipX, u_clipY, u_clipZ, u_clipArb;
            uniform bool u_useX, u_useY, u_useZ, u_useArb;
            varying vec3 v01;
            float win(float v, vec2 c){ return clamp((v-c.x)/max(1e-6,(c.y-c.x)),0.0,1.0); }
            bool allow(vec3 p01){
              vec3 q = p01 - 0.5;
              if(u_useX   && dot(u_clipX.xyz,   q) > u_clipX.w)   return false;
              if(u_useY   && dot(u_clipY.xyz,   q) > u_clipY.w)   return false;
              if(u_useZ   && dot(u_clipZ.xyz,   q) > u_clipZ.w)   return false;
              if(u_useArb && dot(u_clipArb.xyz, q) > u_clipArb.w) return false;
              return true;
            }
            void main(){
              vec2 uv = gl_FragCoord.xy / u_res;
              vec4 exitTex = texture2D(u_exit, uv);
              if(exitTex.a < 0.5) discard;
              vec3 exit01 = exitTex.xyz;

              vec3 start01 = v01;
              vec3 dir01 = exit01 - start01;
              vec3 step01 = dir01 / float(u_steps);

              vec4 accum = vec4(0.0);
              vec3 p = start01;
              for(int i=0;i<1024;i++){
                if(i>=u_steps) break;
                if(allow(p)){
                  float s = texture(u_data, p).r;
                  float w = win(s, u_clim);
                  float a = w * (u_baseA / float(u_steps));
                  accum.rgb += (1.0 - accum.a) * a * vec3(w);
                  accum.a   += (1.0 - accum.a) * a;
                  if(accum.a > 0.995) break;
                }
                p += step01;
              }
              if(accum.a <= 0.0) discard;
              gl_FragColor = vec4(accum.rgb, 1.0);
            }`
                });
                front = new THREE.Mesh(boxGeo, frontMat); volume.add(front);

                // Outline
                volume.add(new THREE.LineSegments(
                    new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1)),
                    new THREE.LineBasicMaterial({ color: 0x888888 })
                ));

                /* ---------- Frames & Proxies ---------- */
                function makeFrameGroup(axis, color = 0xff6b6b) {
                    const rect = new THREE.LineSegments(
                        new THREE.EdgesGeometry(new THREE.BoxGeometry(FRAME_SCALE, FRAME_SCALE, 0.001)),
                        new THREE.LineBasicMaterial({ color, transparent: true, opacity: 1.0 })
                    );
                    const proxy = new THREE.Mesh(
                        new THREE.PlaneGeometry(FRAME_SCALE + FRAME_PROXY_PAD, FRAME_SCALE + FRAME_PROXY_PAD),
                        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false })
                    );
                    proxy.raycast = THREE.Mesh.prototype.raycast;

                    const g = new THREE.Group(); g.add(rect); g.add(proxy);
                    g.userData.rect = rect; g.userData.proxy = proxy; g.userData.axis = axis;

                    proxy.userData.dragOpts = {
                        id: axis, axis: axis, target: g,
                        onChange: () => {
                            if (axis === 'x') g.position.x = Math.max(-0.5, Math.min(0.5, g.position.x));
                            if (axis === 'y') g.position.y = Math.max(-0.5, Math.min(0.5, g.position.y));
                            if (axis === 'z') g.position.z = Math.max(-0.5, Math.min(0.5, g.position.z));
                            syncClipFromFrames();
                        }
                    };
                    rect.userData.dragOpts = proxy.userData.dragOpts;
                    g.userData.dragOpts = proxy.userData.dragOpts;
                    return g;
                }

                const labelOffset = (FRAME_SCALE / 2) + 0.12;
                const labelX = createTextSprite('X', '#ff7777');
                const labelY = createTextSprite('Y', '#ff7777');
                const labelZ = createTextSprite('Z', '#ff7777');

                frameX = makeFrameGroup('x'); frameX.rotation.y = Math.PI / 2; volume.add(frameX);
                frameY = makeFrameGroup('y'); frameY.rotation.x = -Math.PI / 2; volume.add(frameY);
                frameZ = makeFrameGroup('z'); volume.add(frameZ);
                frameZ.userData.proxy.position.z += 0.0001;

                frameX.add(labelX); labelX.position.set(0, labelOffset, 0);
                frameY.add(labelY); labelY.position.set(0, labelOffset, 0);
                frameZ.add(labelZ); labelZ.position.set(0, labelOffset, 0);

                /* ---------- Arbitrary plane ---------- */
                const arbSize = FRAME_SCALE * 1.55;
                const arbGeo = new THREE.PlaneGeometry(arbSize, arbSize, 1, 1);
                const arbRectEdges = new THREE.LineSegments(new THREE.EdgesGeometry(arbGeo), new THREE.LineBasicMaterial({ color: 0xff9955 }));
                arbRect = new THREE.Group(); arbRect.add(arbRectEdges); volume.add(arbRect);

                arbArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.0, 0xff9955, 0.16, 0.10);
                arbRect.add(arbArrow);

                const arrowProxyGeo = new THREE.CylinderGeometry(0.10, 0.10, 1.6, 16, 1, true);
                arrowProxyGeo.rotateX(Math.PI / 2);
                const arrowProxy = new THREE.Mesh(arrowProxyGeo, new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false }));
                arrowProxy.position.set(0, 0, 0.55); arbRect.add(arrowProxy);

                const labelA = createTextSprite('PLANE (OFF)', '#ffbb77'); arbRect.add(labelA); labelA.position.set(0, labelOffset, 0);

                arbRect.userData.dragOpts = { id: 'arb', axis: 'free', target: arbRect, onChange: () => { syncClipFromArb(); } };
                arrowProxy.userData.dragOpts = { id: 'arb-rot', axis: 'free', target: arbRect, onChange: () => { syncClipFromArb(); } };

                // Pickables
                pickables = [
                    frameX.userData.proxy, frameY.userData.proxy, frameZ.userData.proxy,
                    frameX.userData.rect, frameY.userData.rect, frameZ.userData.rect,
                    arbRect, arrowProxy
                ];

                // Tooltip pick box (for dx/dy/dz/dl)
                boxPick = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false })
                );
                volume.add(boxPick);

                // Desktop/touch drag
                const drag = new DragController(camera, renderer.domElement, controls);
                drag.setScene(scene);
                drag.setPickables(pickables);

                const clamp01 = v => Math.max(-0.5, Math.min(0.5, v));
                function syncClipFromFrames() {
                    clip.u_clipX.value.set(1, 0, 0, clamp01(frameX.position.x));
                    clip.u_clipY.value.set(0, 1, 0, clamp01(frameY.position.y));
                    clip.u_clipZ.value.set(0, 0, 1, clamp01(frameZ.position.z));
                }
                function syncClipFromArb() {
                    const nLocal = new THREE.Vector3(0, 0, 1).applyEuler(arbRect.rotation);
                    const s = volume.scale;
                    const nBox = new THREE.Vector3(nLocal.x / s.x, nLocal.y / s.y, nLocal.z / s.z).normalize();
                    const p0Box = new THREE.Vector3(arbRect.position.x / s.x, arbRect.position.y / s.y, arbRect.position.z / s.z);
                    let c = nBox.dot(p0Box);
                    c = THREE.MathUtils.clamp(c, -0.5, 0.5);
                    const posLocal = new THREE.Vector3(nBox.x * c * s.x, nBox.y * c * s.y, nBox.z * c * s.z);
                    arbRect.position.copy(posLocal);
                    arbArrow.setDirection(nBox); arbArrow.position.set(0, 0, 0);
                    clip.u_clipArb.value.set(nBox.x, nBox.y, nBox.z, c);
                }

                // Initial
                clip.u_clipX.value.w = 0.5; clip.u_clipY.value.w = 0.5; clip.u_clipZ.value.w = 0.5;
                clip.u_clipArb.value.set(0, 0, 1, 0.5);
                syncClipFromFrames();
                syncClipFromArb();
                arbRect.visible = false;

                /* ---------- GUI ---------- */
                const gui = new GUI({ width: 260 });
                const params = {
                    'X plane': true,
                    'Y plane': true,
                    'Z plane': true,
                    'Arbitrary plane (orange)': false,
                    'Show tooltip': false
                };
                gui.add(params, 'X plane').onChange(v => { clip.u_useX.value = v; frameX.visible = v; });
                gui.add(params, 'Y plane').onChange(v => { clip.u_useY.value = v; frameY.visible = v; });
                gui.add(params, 'Z plane').onChange(v => { clip.u_useZ.value = v; frameZ.visible = v; });
                gui.add(params, 'Arbitrary plane (orange)').onChange(v => {
                    clip.u_useArb.value = v; arbRect.visible = v; labelA.userData.setText(`PLANE (${v ? 'ON' : 'OFF'})`);
                });
                gui.add(params, 'Show tooltip');

                // Tooltip hover
                function setPointerFromEvent(e) {
                    const r = renderer.domElement.getBoundingClientRect();
                    pointerNDC.x = ((e.clientX - r.left) / r.width) * 2 - 1; pointerNDC.y = -((e.clientY - r.top) / r.height) * 2 + 1;
                }
                function ascendToFrameGroup(o) { while (o && !(o.userData && o.userData.rect)) o = o.parent; return o; }
                function updateHover(e) {
                    setPointerFromEvent(e); hoverRay.setFromCamera(pointerNDC, camera);
                    const hits = hoverRay.intersectObjects(pickables, true);
                    const hit = hits[0];
                    const hitGroup = hit ? ascendToFrameGroup(hit.object) : null;
                    if (hoveredFrame && hoveredFrame !== hitGroup) hoveredFrame.userData.rect.material.color.copy(baseCol);
                    if (hitGroup && hoveredFrame !== hitGroup) hitGroup.userData.rect.material.color.copy(hiCol);
                    hoveredFrame = hitGroup || null;

                    if (!params['Show tooltip']) { tooltipEl.style.display = 'none'; return; }
                    const boxHits = hoverRay.intersectObject(boxPick, true);
                    if (boxHits.length === 0) { tooltipEl.style.display = 'none'; return; }
                    const pWorld = boxHits[0].point.clone();
                    const pLocal = volume.worldToLocal(pWorld.clone());
                    const dx = pLocal.x.toFixed(3);
                    const dy = pLocal.y.toFixed(3);
                    const dz = pLocal.z.toFixed(3);
                    const dl = Math.hypot(pLocal.x, pLocal.y, pLocal.z).toFixed(3);
                    tooltipEl.textContent = `dx: ${dx}\ndy: ${dy}\ndz: ${dz}\ndl: ${dl}`;
                    tooltipEl.style.left = `${e.clientX}px`;
                    tooltipEl.style.top = `${e.clientY}px`;
                    tooltipEl.style.display = 'block';
                }
                renderer.domElement.addEventListener('pointermove', updateHover);
                renderer.domElement.addEventListener('pointerleave', () => {
                    if (hoveredFrame) hoveredFrame.userData.rect.material.color.copy(baseCol);
                    hoveredFrame = null; tooltipEl.style.display = 'none';
                });

                /* ---------- Progressive: coarse first (no retention), then stream full ---------- */
                function gray(data, i2d) { return ((data[i2d] + data[i2d + 1] + data[i2d + 2]) / 3) | 0; }

                async function buildCoarsePlaceholder(W, H, D, step) {
                    const vol = new Uint8Array(W * H * D);
                    for (let z = 0; z < D; z += step) {
                        const src = sliceIndexForZ(z);
                        const img = await loadImageData(IMG_PATH(src), W, H);
                        const base3d = z * W * H;
                        for (let y = 0; y < H; y++) {
                            const rowBase = y * W;
                            for (let x = 0; x < W; x++) {
                                const i2d = (y * W + x) * 4;
                                vol[base3d + rowBase + x] = gray(img.data, i2d);
                            }
                        }
                        const nextZ = Math.min(D - 1, z + step);
                        for (let zz = z + 1; zz < nextZ; zz++) {
                            const dstBase = zz * W * H;
                            vol.set(vol.subarray(base3d, base3d + W * H), dstBase);
                        }
                    }
                    return vol;
                }

                // Coarse first
                progressEl.style.display = 'block';
                progressEl.textContent = 'Preparing coarse volume...';
                volU8 = await buildCoarsePlaceholder(W, H, D, K_COARSE);
                tex3D = new THREE.Data3DTexture(volU8, W, H, D);
                tex3D.format = THREE.RedFormat;
                tex3D.type = THREE.UnsignedByteType;
                tex3D.minFilter = THREE.LinearFilter;
                tex3D.magFilter = THREE.LinearFilter;
                tex3D.unpackAlignment = 1;
                tex3D.wrapS = tex3D.wrapT = tex3D.wrapR = THREE.ClampToEdgeWrapping;
                tex3D.needsUpdate = true;
                frontMat.uniforms.u_data.value = tex3D;

                // Stream all slices (stride-aware), copyâ†’discard
                let loadedCount = 0;
                await new Promise((resolve, reject) => {
                    const queue = [...Array(D).keys()];
                    let active = 0, i = 0;

                    const tick = () => {
                        const pct = Math.round((loadedCount / D) * 100);
                        progressEl.textContent = `Loading slices: ${loadedCount}/${D} (${pct}%)`;
                    };

                    const kick = () => {
                        while (active < MAX_CONCURRENCY && i < queue.length) {
                            const z = queue[i++]; active++;
                            const src = sliceIndexForZ(z);
                            loadImageData(IMG_PATH(src), W, H)
                                .then(img => {
                                    const data = img.data;
                                    const base3d = z * W * H;
                                    for (let y = 0; y < H; y++) {
                                        const rowBase = y * W;
                                        for (let x = 0; x < W; x++) {
                                            const i2d = (y * W + x) * 4;
                                            volU8[base3d + rowBase + x] = gray(data, i2d);
                                        }
                                    }
                                    loadedCount++;
                                    if ((loadedCount % PROGRESS_UPDATE_EVERY) === 0) tex3D.needsUpdate = true;
                                })
                                .catch(reject)
                                .finally(() => {
                                    active--;
                                    if (i >= queue.length && active === 0) resolve();
                                    else kick();
                                });
                        }
                    };
                    tick();
                    kick();
                });

                tex3D.needsUpdate = true;
                progressEl.style.display = 'none';

                /* ---------- VR controllers & locomotion ---------- */
                const controllerModelFactory = new XRControllerModelFactory();

                function makeController(i) {
                    const c = renderer.xr.getController(i); c.userData.index = i;

                    // visible ray
                    const rayGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
                    const ray = new THREE.Line(rayGeom, new THREE.LineBasicMaterial({ transparent: true, opacity: 0.6 }));
                    ray.scale.z = 3.0; c.add(ray);

                    c.addEventListener('selectstart', onSelectStart);
                    c.addEventListener('selectend', onSelectEnd);
                    c.addEventListener('squeezestart', onSqueezeStart);
                    c.addEventListener('squeezeend', onSqueezeEnd);

                    scene.add(c);
                    const grip = renderer.xr.getControllerGrip(i);
                    grip.add(controllerModelFactory.createControllerModel(grip));
                    scene.add(grip);
                    return c;
                }
                const controller1 = makeController(0);
                const controller2 = makeController(1);

                const vrRaycaster = new THREE.Raycaster();
                const vrTargets = pickables;
                let vrDrag = null;  // { controller, obj, plane, offset, opts, mode }
                let grabbing = null;// { controller, worldToController }

                function buildPointerRay(controller) {
                    const m = controller.matrixWorld;
                    const origin = new THREE.Vector3().setFromMatrixPosition(m);
                    const dir = new THREE.Vector3(0, 0, -1).applyMatrix4(new THREE.Matrix4().extractRotation(m)).normalize();
                    return { origin, dir };
                }
                function onSelectStart(e) {
                    const c = e.target;
                    const { origin, dir } = buildPointerRay(c);
                    vrRaycaster.ray.origin.copy(origin);
                    vrRaycaster.ray.direction.copy(dir);

                    const hits = vrRaycaster.intersectObjects(vrTargets, true);
                    if (!hits.length) return;

                    let o = hits[0].object;
                    while (o && !o.userData.dragOpts) o = o.parent;
                    if (!o) return;
                    const opts = o.userData.dragOpts;
                    const obj = opts.target || o;

                    const n = dir.clone().negate();
                    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(n, hits[0].point.clone());
                    const offset = hits[0].point.clone().sub(obj.getWorldPosition(new THREE.Vector3()));

                    vrDrag = { controller: c, obj, opts, plane, offset, mode: (opts.id === 'arb-rot' ? 'rotate' : 'translate') };
                }
                function onSelectEnd() { vrDrag = null; }

                function onSqueezeStart(e) {
                    const c = e.target;
                    const inv = new THREE.Matrix4().copy(c.matrixWorld).invert();
                    const worldToController = new THREE.Matrix4().multiplyMatrices(inv, worldRoot.matrixWorld);
                    grabbing = { controller: c, worldToController };
                }
                function onSqueezeEnd() { grabbing = null; }

                const SNAP_DEG = 30;
                const DEADZONE = 0.35;
                let snapCooldown = 0;
                function processThumbsticks(dt) {
                    [controller1, controller2].forEach(c => {
                        const gp = c.gamepad;
                        if (!gp || !gp.axes) return;
                        const x = gp.axes[2] ?? gp.axes[0] ?? 0;
                        if (snapCooldown > 0) return;
                        if (x > DEADZONE) { worldRoot.rotateY(-THREE.MathUtils.degToRad(SNAP_DEG)); snapCooldown = 0.2; }
                        else if (x < -DEADZONE) { worldRoot.rotateY(+THREE.MathUtils.degToRad(SNAP_DEG)); snapCooldown = 0.2; }
                    });
                }

                function updateVR(dt) {
                    if (vrDrag) {
                        const c = vrDrag.controller;
                        const { origin, dir } = buildPointerRay(c);
                        const p = new THREE.Vector3();
                        const line = new THREE.Line3(origin, origin.clone().addScaledVector(dir, 10));
                        if (vrDrag.plane.intersectLine(line, p)) {
                            const targetWorld = p.clone().sub(vrDrag.offset);
                            const parent = vrDrag.obj.parent || scene;
                            const targetLocal = parent.worldToLocal(targetWorld);
                            const { obj, opts } = vrDrag;
                            if (opts.axis === 'x') { targetLocal.y = obj.position.y; targetLocal.z = obj.position.z; }
                            if (opts.axis === 'y') { targetLocal.x = obj.position.x; targetLocal.z = obj.position.z; }
                            if (opts.axis === 'z') { targetLocal.x = obj.position.x; targetLocal.y = obj.position.y; }
                            obj.position.copy(targetLocal);
                            opts.onChange(obj);
                        }
                    }
                    if (grabbing) {
                        const m = new THREE.Matrix4().multiplyMatrices(grabbing.controller.matrixWorld, grabbing.worldToController);
                        worldRoot.matrix.copy(m);
                        worldRoot.matrix.decompose(worldRoot.position, worldRoot.quaternion, worldRoot.scale);
                    }
                    processThumbsticks(dt);
                    if (snapCooldown > 0) snapCooldown -= dt;
                }

                /* ---------- Render (VR-safe two-pass) ---------- */
                fitCameraToObject(worldRoot, 1.35);
                hud.textContent =
                    `Touch/Desktop:
 â€¢ Orbit: 1-finger rotate â€¢ 2-finger dolly/pan
 â€¢ Drag a red frame to move that axis-plane; toggle orange plane in GUI
VR:
 â€¢ Trigger = drag frames/plane â€¢ Grip = grab world â€¢ Stick = snap-turn
Perf:
 â€¢ Streamed slices, MAX_3D=${MAX3D}, stride=${depthStride}, DPR=${renderer.getPixelRatio()}`;

                // Resize exit RT to XR render size on session start/end
                function resizeExitRTToXR() {
                    const sz = renderer.getDrawingBufferSize(new THREE.Vector2());
                    rt.setSize(sz.x, sz.y);
                    frontMat.uniforms.u_res.value.set(sz.x, sz.y);
                }
                renderer.xr.addEventListener('sessionstart', () => {
                    resizeExitRTToXR();
                    frontMat.uniforms.u_steps.value = Math.round(frontMat.uniforms.u_steps.value * 1.2); // a touch more quality in XR
                });
                renderer.xr.addEventListener('sessionend', () => {
                    const dpr = renderer.getPixelRatio();
                    rt.setSize(Math.floor(innerWidth * dpr), Math.floor(innerHeight * dpr));
                    frontMat.uniforms.u_res.value.set(rt.width, rt.height);
                });

                let lastT = performance.now();
                function render() {
                    const now = performance.now();
                    const dt = (now - lastT) / 1000; lastT = now;

                    const inXR = renderer.xr.isPresenting;

                    // Pass 1: back faces â†’ exit coords (force MONO in XR to avoid stereo mismatch/static)
                    const prevXR = renderer.xr.enabled;
                    if (inXR) renderer.xr.enabled = false;
                    back.visible = true; front.visible = false;
                    renderer.setRenderTarget(rt);
                    renderer.setClearColor(0x000000, 0.0);
                    renderer.clear(true, true, true);
                    renderer.render(scene, camera);   // scene contains worldRootâ†’volume
                    renderer.setRenderTarget(null);
                    if (inXR) renderer.xr.enabled = prevXR;

                    // Pass 2: front faces â†’ main (stereo if inXR)
                    back.visible = false; front.visible = true;
                    renderer.render(scene, camera);

                    if (!inXR) controls.update();
                    if (inXR) updateVR(dt);
                }
                renderer.setAnimationLoop(render);

                // Resize
                addEventListener('resize', () => {
                    camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(innerWidth, innerHeight);
                    if (!renderer.xr.isPresenting) {
                        const dpr = renderer.getPixelRatio();
                        rt.setSize(Math.floor(innerWidth * dpr), Math.floor(innerHeight * dpr));
                        frontMat.uniforms.u_res.value.set(rt.width, rt.height);
                    }
                });

                // WebXR UI (button or tip)
                setupVRUI();
                async function setupVRUI() {
                    let supportsImmersiveVR = false;
                    if (navigator.xr && navigator.xr.isSessionSupported) {
                        try { supportsImmersiveVR = await navigator.xr.isSessionSupported('immersive-vr'); } catch { }
                    }
                    if (supportsImmersiveVR) {
                        document.body.appendChild(VRButton.createButton(renderer));
                    } else {
                        tip.textContent = 'VR not available on this device/browser. Use a WebXR headset (e.g., Quest) for immersive mode.';
                        tip.style.display = 'block';
                    }
                }

            } catch (err) {
                const msg = document.createElement('div');
                msg.style.cssText = `
          position:fixed; left:8px; top:8px; z-index:9999;
          background:rgba(0,0,0,.85); color:#fff; padding:10px 12px;
          border-radius:8px; max-width:90vw; font:12px system-ui; white-space:pre-wrap;
        `;
                msg.textContent = 'Error: ' + (err?.message || err);
                document.body.appendChild(msg);
                console.error(err);
            }
        })();
    </script>
</body>

</html>